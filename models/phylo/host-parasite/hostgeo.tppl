/*
 *   Host repertoire model that accounts for host geographic distribution
 *	 (Mariana, Alex and Fredrik)
 */

/*---------------------------- TYPES --------------------------------*/

// TreeLabeled is like the built in Tree type, but with leaf and node labels
type TreeLabeled =
  | Leaf{age: Real, label: Int}
  | Node{age: Real, left: TreeLabeled, right: TreeLabeled, label: Int}

/*-------------------- Model-specific types -------------------------*/

// Biogeography types ----------------

type GeoTree =
	| Leaf{age: Real, label: Int, region: Int}
	| Node{age: Real, label: Int, region: Int, left: GeoTree, right: GeoTree}
	| SwitchNode{age: Real, index: Int, from_region: Int, to_region: Int, child: GeoTree}

// Tree decorated with postorder messages from belief propagation from biogeo.
// Postorder = backwards in time
type GeoMsgTree =
	| GeoMsgLeaf{age: Real, label: Int, region: Int, out_msg: Tensor[Real][]}
	| GeoMsgNode{age: Real, label: Int, region: Int, left: GeoMsgTree, right: GeoMsgTree,
           left_in_msg: Tensor[Real][], right_in_msg: Tensor[Real][], out_msg: Tensor[Real][]}
	| GeoMsgSwitchNode{age: Real, index: Int, from_region: Int, to_region: Int, child: GeoMsgTree,
										in_msg: Tensor[Real][], out_msg: Tensor[Real][]}

// Tree decorated with final probabilities from belief propagation,
// tuned so that they are useful for proposals.
type GeoProbsTree =
	| GeoProbsLeaf{age: Real, label: Int, probs: Tensor[Real][]}
	| GeoProbsNode{age: Real, label: Int, probs: Tensor[Real][],
             left: GeoProbsTree, right: GeoProbsTree}
	| GeoProbsSwitchNode{age: Real, index: Int, from_region: Int, to_region: Int, 
											 child: GeoProbsTree, probs: Tensor[Real][]} 


// Host repertoire types ---------------

// Tree decorated with postorder messages from belief propagation.
// Postorder = backwards in time
type MsgTree =
	| MsgLeaf{age: Real, label: Int, out_msg: Tensor[Real][]}
	| MsgNode{age: Real, label: Int, left: MsgTree, right: MsgTree,
           left_in_msg: Tensor[Real][], right_in_msg: Tensor[Real][], out_msg: Tensor[Real][]}

// Tree decorated with final probabilities from belief propagation,
// tuned so that they are useful for proposals.
type ProbsTree =
	| ProbsLeaf{age: Real, label: Int, probs: Tensor[Real][]}
	| ProbsNode{age: Real, label: Int, probs: Tensor[Real][],
             left: ProbsTree, right: ProbsTree}

// Event type used to store information about one host-repertoire change
// We keep the from_state here just in case we want to use it for debugging
type Event = Event{age: Real, host: Int, from_state: Int, to_state: Int}

// Type used to hold a proposed history of state changes for a branch
type ProposedHistory = ProposedHistory{log_debt: Real, events: Event[]}

// History point type used to store repertoire snapshots at the repertoire
// start ages, which is the time of the event that led to that combination
type HistoryPoint = HistoryPoint{age: Real, repertoire: Int[]}

// HistoryScore type used to store a vector of history points and a log
// score associated with this history.
type HistoryScore = HistoryScore{log_score: Real, history: HistoryPoint[]}

// Tree decorated with ancestral host repertoires and branch repertoire histories
type HistoryTree =
  | HistoryLeaf{age: Real, label: Int, repertoire: Int[], history: HistoryPoint[], log_rep_debt: Real}
  | HistoryNode{age: Real, label: Int, repertoire: Int[], history: HistoryPoint[], log_rep_debt: Real,
                left: HistoryTree, right: HistoryTree}

type ModelParams = 
	ModelParams{qMatrix: Tensor[Real], dMatrix: Tensor[Real], dMean: Real, beta: Real}

// Type used to hold the character histories and parameter values to be outputed
//type ReturnType = ReturnType{tree: HistoryTree, lambda: Real[], mu: Real, beta: Real}
type ReturnType = ReturnType{tree: GeoTree}

