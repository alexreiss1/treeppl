/*
 *   Host repertoire model that accounts for host geographic distribution
 *	 (Mariana, Alex and Fredrik)
 */

/*---------------------------- TYPES --------------------------------*/

// TreeLabeled is like the built in Tree type, but with leaf and node labels
type TreeLabeled =
  | Leaf{age: Real, label: Int}
  | Node{age: Real, left: TreeLabeled, right: TreeLabeled, label: Int}

/*-------------------- Model-specific types -------------------------*/


// Use MsgTree type for belief propagation of biogeo
// Update tree types for host rep


// Biogeography types ----------------

// Tree decorated with postorder messages from belief propagation from biogeo.
// Postorder = backwards in time
type GeoMsgTree =
	| GeoMsgLeaf{age: Real, label: Int, out_msg: Tensor[Real][]}
	| GeoMsgNode{age: Real, label: Int, left: GeoMsgTree, right: GeoMsgTree,
           left_in_msg: Tensor[Real][], right_in_msg: Tensor[Real][], out_msg: Tensor[Real][]}

// Tree decorated with final probabilities from belief propagation,
// tuned so that they are useful for proposals.
type GeoProbsTree =
	| GeoProbsLeaf{age: Real, label: Int, probs: Tensor[Real][]}
	| GeoProbsNode{age: Real, label: Int, left: GeoProbsTree, right: GeoProbsTree, 
								 probs: Tensor[Real][]}

// History point type used to store geo distribution snapshots at the 
// start ages, which is the time of the dispersal event to that region
type GeoHistoryPoint = GeoHistoryPoint{age: Real, region: Int}

// Tree with simulated biogeography history 
type GeoHistoryTree =
	| GeoHistoryLeaf{age: Real, label: Int, region: Int, geo_history: GeoHistoryPoint[], log_geo_debt: Real}
	| GeoHistoryNode{age: Real, label: Int, region: Int, left: GeoHistoryTree, right: GeoHistoryTree, 
						geo_history: GeoHistoryPoint[], log_geo_debt: Real}
	| GeoHistorySwitchNode{age: Real, index: Int, from_region: Int, to_region: Int, child: GeoHistoryTree,
									geo_history: GeoHistoryPoint[], log_geo_debt: Real}

// GeoHistoryScore type used to store a vector of history points and a log
// score associated with this biogeographic history.
type GeoHistoryScore = GeoHistoryScore{geo_log_score: Real, geo_history: GeoHistoryPoint[]}

// Host repertoire types ---------------

// Tree decorated with postorder messages from belief propagation.
// Postorder = backwards in time
type MsgTree =
	| MsgLeaf{age: Real, label: Int, region: Int, out_msg: Tensor[Real][]}
	| MsgNode{age: Real, label: Int, region: Int, left: MsgTree, right: MsgTree,
           left_in_msg: Tensor[Real][], right_in_msg: Tensor[Real][], out_msg: Tensor[Real][]}
	| MsgSwitchNode{age: Real, index: Int, from_region: Int, to_region: Int, child: MsgTree,
									in_msg: Tensor[Real][], out_msg: Tensor[Real][]}

// Tree decorated with final probabilities from belief propagation,
// tuned so that they are useful for proposals.
type ProbsTree =
	| ProbsLeaf{age: Real, label: Int, region: Int, probs: Tensor[Real][]}
	| ProbsNode{age: Real, label: Int, region: Int, probs: Tensor[Real][],
             left: ProbsTree, right: ProbsTree}
	| ProbsSwitchNode{age: Real, index: Int, from_region: Int, to_region: Int, 
										child: GeoProbsTree, probs: Tensor[Real][]} 

// Event type used to store information about one host-repertoire change
// We keep the from_state here just in case we want to use it for debugging
type Event = Event{age: Real, host: Int, from_state: Int, to_state: Int}

// Type used to hold a proposed history of state changes for a branch
type ProposedHistory = ProposedHistory{log_debt: Real, events: Event[]}

// History point type used to store repertoire snapshots at the repertoire
// start ages, which is the time of the event that led to that combination
type HistoryPoint = HistoryPoint{age: Real, repertoire: Int[]}

// HistoryScore type used to store a vector of history points and a log
// score associated with this history.
type HistoryScore = HistoryScore{log_score: Real, history: HistoryPoint[]}

// Tree decorated with ancestral host repertoires and branch repertoire histories
type HistoryTree =
  | HistoryLeaf{age: Real, label: Int, repertoire: Int[], history: HistoryPoint[], log_rep_debt: Real}
  | HistoryNode{age: Real, label: Int, repertoire: Int[], history: HistoryPoint[], log_rep_debt: Real,
                left: HistoryTree, right: HistoryTree}

type ModelParams = 
	ModelParams{qMatrix: Tensor[Real], dMatrix: Tensor[Real], dMean: Real, beta: Real}

// Type used to hold the character histories and parameter values to be outputed
//type ReturnType = ReturnType{tree: HistoryTree, lambda: Real[], mu: Real, beta: Real}
type ReturnType = ReturnType{tree: GeoTree}


model function mymodel(symbiont_tree: TreeLabeled, ntips: Int, nhosts: Int, nregions: Int, interactions: Int[],
	symbiont_geo: Int[], host_geo: Int[], host_distances: Real[], dMean: Real, tune: Real): () {

	// Set prior for dispersal parameter
	assume gamma ~ Exponential(10.0);

	// Set dispersal matrix for n regions
	// build a matrix of arbitrary size so that all off-diagonal elements = gamma,
	// and diagonal = - gamma * (nregions - 1)  TODO for loop?
  let g_matrix = mtxCreate(2,2,[-gamma, gamma, gamma, -gamma]);
	printMtx(g_matrix);

	let sym_geo_matrix = mtxCreate(ntips, 1, sint2real(symbiont_geo));
	//printMtx(sym_geo_matrix);

  // Derive params for ancestral biogeography proposal
	let geo_stationary_probs = rvecCreate(1, [1.0/Real(nregions)]);
  let geo_probs_tree = get_geo_proposal_params(symbiont_tree, symbiont_geo, g_matrix, geo_stationary_probs, tune);
	
	printMtx(geo_probs_tree.probs[1]);

	assume cat_sample ~ Categorical( rvec2seq(geo_probs_tree.probs[1]) ); // TODO CHECK
	let geo_root = addi(cat_sample, 1);

	printLn(int2string(geo_root));

  let left = simulate_geo(geo_probs_tree.left, GeoHistoryPoint{age = geo_probs_tree.age, region = geo_root}, g_matrix, sym_geo_matrix);
  let right = simulate_geo(geo_probs_tree.right, GeoHistoryPoint{age = geo_probs_tree.age, region = geo_root}, g_matrix, sym_geo_matrix);



}


// ----- Proposal of symbiont biogeographic history ----- //

// Get proposal probabilities for biogeo history
function get_geo_proposal_params(symbiont_tree: TreeLabeled, symbiont_geo: Int[], g_matrix: Tensor[Real], 
  geo_stationary_probs: Tensor[Real], tune: Real): GeoProbsTree {

  let geo_msg_tree = geo_postorder_msgs(symbiont_tree, symbiont_geo, g_matrix);  
  //let n = length(getMsgTreeMsg(msgTree));
  let n = length(geo_msg_tree.out_msg);
	let pis = rep(n, geo_stationary_probs);
  return geo_final_probs(geo_msg_tree, pis, g_matrix, tune);

}

// Compute postorder biogeo messages on the observed tree
function geo_postorder_msgs(tree: TreeLabeled, symbiont_geo: Int[], g_matrix: Tensor[Real]) : GeoMsgTree {

  if tree is Leaf {
    return GeoMsgLeaf{age = 0.0, label = tree.label, out_msg = make_geo_message(symbiont_geo[tree.label])};
  }

  let left  = geo_postorder_msgs(tree.left , symbiont_geo, g_matrix);
  let right = geo_postorder_msgs(tree.right, symbiont_geo, g_matrix);

  let tMatrixLeft = mtxTrans(mtxExp(mtxSclrMul(tree.age-left.age, g_matrix)));   
  let tMatrixRight = mtxTrans(mtxExp(mtxSclrMul(tree.age-right.age, g_matrix)));

	// TODO: decide here wether to keep the same structure for messages ( Tensor[Real][] )
	// or update code to take just a Tensor[Real]
  let left_in_msg  = sapply1(left.out_msg, mtxMul, tMatrixLeft);
  let right_in_msg = sapply1(right.out_msg, mtxMul, tMatrixRight);

  let out_msg = normalizeMessage(mulMessage(left_in_msg, right_in_msg));

  return GeoMsgNode{age= tree.age, label= tree.label, left= left, right= right, 
    left_in_msg = left_in_msg, right_in_msg = right_in_msg, out_msg = out_msg};

}


// TODO do this properly. Now it's hardcoded for 2 regions only
function make_geo_message(elem: Int): Tensor[Real][] {
	if (eqi(elem, 1)) {
		return [rvecCreate( 2, [1.0, 0.0] )];
	} else {
			if (eqi(elem, 2)) {
				return [rvecCreate( 2, [0.0, 1.0] )];
		} else {
				return [rvecCreate( 2, [1.0, 1.0] )] ;
		}
	}
}


// Compute final probabilities from geo belief propagation on the observed symbiont tree
function geo_final_probs(tree: GeoMsgTree, parent_msg: Tensor[Real][], g_matrix: Tensor[Real], tune: Real) : GeoProbsTree {
    
  let probs = normalizeMessage(
		messageElementPower(mulMessage(tree.out_msg, parent_msg), tune)
  );

  if tree is GeoMsgLeaf {
    return GeoProbsLeaf{age= 0.0, label= tree.label, probs = probs};
  } 

  let left_branch = tree.age - getMsgTreeAge(tree.left);
  let right_branch = tree.age - getMsgTreeAge(tree.right);

  let tMatrixLeft = mtxExp(mtxSclrMul(left_branch, g_matrix));
  let tMatrixRight = mtxExp(mtxSclrMul(right_branch, g_matrix));

  let left_parent_msg  = sapply1(mulMessage(parent_msg,tree.left_in_msg), mtxMul, tMatrixLeft);
  let right_parent_msg = sapply1(mulMessage(parent_msg,tree.right_in_msg), mtxMul, tMatrixRight);

  let left  =  geo_final_probs(tree.left,  left_parent_msg, g_matrix, tune);
  let right =  geo_final_probs(tree.right, right_parent_msg, g_matrix, tune);

  return GeoProbsNode{age = tree.age, label = tree.label, left = left, right = right, probs = probs};
}


// ------ Simulate biogeographic history ------------ //

function simulate_geo(tree: GeoProbsTree, start: GeoHistoryPoint, g_matrix: Tensor[Real], sym_geo_matrix: Tensor[Real]): GeoHistoryTree {

	assume region ~ Categorical( rvec2seq(tree.probs[1]) );
	
	let stop = GeoHistoryPoint{age = tree.age, region = region};

	if tree is GeoProbsLeaf {
		return geo_history = simulate_geo_history(start, stop, g_matrix);
	}



	let left = simulate_geo(tree.left, stop, g_matrix, sym_geo_matrix);
	let right = simulate_geo(tree.right, stop, g_matrix, sym_geo_matrix);

	return 
}


function simulate_geo_history(from_point: GeoHistoryPoint, end_point: GeoHistoryPoint, end_debt_node: GeoTree, g_matrix: Tensor[Real]): GeoHistoryScore {

	let from_state = from_point.region;
	let end_state = end_point.region;
	let from_age = from_point.age;
	let end_age = end_point.age;

	let rate = -(mtxGet(from_point.region, from_point.region, g_matrix));

  if (rate * (from_point.age - end_point.age) < 1E-15 && !eqi(from_point.region, end_point.region)) {
    weight 0.0;
    resample;
  }

	let t = getWaitingTime(from_point.region, end_point.region, rate, from_point.age, end_point.age);
	let new_age = from_point.age - t;

	if (new_age < end_age) {
		let log_wait_debt = poissonLogScore(0, PoissonParam{rate = rate*(from_age - end_age)});
		return GeoHistoryScore{geo_log_score = log_wait_debt + end_debt_node.log_debt, geo_tree = end_debt_node.geo_tree};
	}

	printLn("do something");
	return GeoHistoryScore{geo_log_score = end_debt_node.log_debt, geo_tree = end_debt_node.geo_tree};
	// Case when a dispersal event occurs
	// Create GeoSwitchNode
	
}

 

function getWaitingTime(from_state: Int, end_state: Int, rate: Real, from_age: Real, end_age: Real): Real {
	if (!eqi(from_state,end_state)) {
		return sample_exponential_max_t(rate, from_age - end_age);
	} else {
		assume t ~ Exponential(rate);
		return t;
	}
}


function rvec2seq(t: Tensor[Real]): Real[] {
	let n = dim(t)[2];
	let myRng = 1 to n;
	let myFun = getRowVecElem(t);
	let mySeq = sapply(myRng, myFun);
	return mySeq;
}

function getRowVecElem(t: Tensor[Real], i: Int): Real {
  return mtxGet(1, i, t);
}

function getMsgTreeAge(tree: GeoMsgTree) : Real {
	return tree.age;
}